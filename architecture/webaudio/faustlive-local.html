<!DOCTYPE html PUBLIC>
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <style type="text/css">
    body {
        background-color: #000000;
    }

    /* WEBKIT */
    text {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .faust-group-label {
        font-family: Arial, Verdana, Helvetica, sans;
        font-size: 13px;
        fill: rgba(199,190,162,0.6);
    }

    .faust-tooltip-text {
        font-family: Arial, Verdana, Helvetica, sans;
        font-size: 13px;
    }

    .faust-button-label {
        font-family: Arial, Verdana, Helvetica, sans;
        font-size: 13px;
        fill: rgba(0,182,253,0.6);
    }

    .faust-tgroup-label {
        font-family: Arial, Verdana, Helvetica, sans;
        font-size: 13px;
        fill: rgba(0,182,253,0.6);
    }

    .faust-label {
        font-family: Arial, Verdana, Helvetica, sans;
        font-size: 13px;
        fill: rgba(0,182,253,0.6);
    }

    .faust-value-text {
        font-family: Arial, Verdana, Helvetica, sans;
        font-size: 11px;
        font-weight: bold;
        fill: rgb(82,79,79);
    }

    path {
      -webkit-user-select: none;
    }

    rect {
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    }

    circle {
      -webkit-user-select: none;
    }

    text:hover {
      cursor: default;
    }

    path.faust-vbox {
      fill : white;
      stroke : black;
    }

    path.faust-rbutton-groove {
      fill : rgb(152,251,152);
      stroke : black;
    }

    path.faust-rbutton-handle {
      fill : grey;
      stroke : black;
    }

    rect.faust-hslider-meter {
      fill : url(#horizontalSliderMeterGradient);
      width : 175;
      height : 40;
    }

    rect.faust-hslider-groove {
      fill : rgba(28,126,192,0.65);
      stroke : rgba(0,182,253,0.9);
      width : 175;
      height : 40;
    }

    rect.faust-hslider-handle {
      fill : url(#horizontalSliderHandleGradient);
      stroke : black;
      width : 30;
      height : 40;
    }

    rect.faust-vslider-meter {
      fill : url(#verticalSliderMeterGradient);
      height : 175;
      width : 40;
    }

    rect.faust-vslider-groove {
      fill : rgba(28,126,192, 0.65);
      stroke : rgba(0,182,253,0.9);
      width : 40;
      height : 175;
    }

    rect.faust-vslider-handle {
      fill : url(#verticalSliderHandleGradient);
      stroke : black;
      width : 40;
      height : 30;
    }

    rect.faust-hbargraph-curtain {
      fill : rgb(20,20,20);
      stroke : black;
      width : 200;
      height : 30;
    }

    // hbargraph meters cannot be defined via CSS because their widths and
    // heights are dynamic

    rect.faust-hbargraph-meter {
      fill : url(#horizontalBarGraphMeterGradient);
      stroke : black;
    }

    rect.faust-vbargraph-curtain {
      fill : rgb(20,20,20);
      stroke : black;
      width : 30;
      height : 200;
    }

    rect.faust-vbargraph-meter {
      fill : url(#verticalBarGraphMeterGradient);
      stroke : black;
    }

    rect.faust-checkbox-box {
      fill : white;
      stroke : black;
      width : 19;
      height : 19;
    }

    path.faust-checkbox-check {
      fill : black;
      stroke : black;
    }

    rect.faust-nentry-box {
      fill : url(#numericalEntryUpGradient);
      stroke : black;
      width : 60;
      height : 20;
    }

    path.faust-nentry-operation {
      stroke : black;
    }

    rect.faust-button-box {
      fill : url(#buttonUpGradient);
      stroke : black;
      width : 80;
      height : 40;
    }

    rect.faust-tgroup-box {
      fill : url(#tabGroupUpGradient);
      stroke : black;
    }

    circle.faust-rbutton-groove {
      fill : url(#rotatingButtonHandleGradient);
    }

    circle.faust-rbutton-dot {
      fill : pink;
      stroke : black;
    }

    path.faust-rbutton-meter {
      fill : rgb(50,50,50);
    }

    path.faust-rbutton-mgroove {
      fill : url(#rotatingButtonMeterGradient);
    }

    // as all of the above rectangles could be implemented as paths, we duplicate the definitions for paths

    path.faust-hslider-groove {
      fill : red;
      stroke : black;
    }

    path.faust-hslider-handle {
      fill : url(#horizontalSliderHandleGradient);
      stroke : black;
    }

    path.faust-vslider-groove {
      fill : red;
      stroke : black;
    }

    path.faust-vslider-handle {
      fill : url(#verticalSliderHandleGradient);
      stroke : black;
    }

    path.faust-hbargraph-curtain {
      fill : rgb(0,255,255);
      stroke : black;
    }

    path.faust-hbargraph-meter {
      fill : grey;
      stroke : black;
    }

    path.faust-vbargraph-curtain {
      fill : rgb(0,255,255);
      stroke : black;
    }

    path.faust-vbargraph-meter {
      fill : grey;
      stroke : black;
    }

    path.faust-checkbox-box {
      fill : white;
      stroke : black;
    }

    path.faust-nentry-box {
      fill : url(#numericalEntryUpGradient);
      stroke : black;
    }

    path.faust-button-box {
      fill : #B0B0B0;
      stroke : black;
    }
    
    #filedrag{
        font-weight: bold;
        text-align: center;
        padding: 1em 0;
        margin: 1em 0;
        color: #CECECE;
        border: 8px dashed #CECECE;
        border-radius: 7px;
        cursor: default;
        font-size : 20px;
    }

    #filedrag.hover{
        color: #FF7F00;
        border-color: #FF7F00;
        border-style: solid;
    }
    </style>

</head>
<body bgcolor= "#000000">
<div id="filedrag">
    Embedded Faust compiler : drop your .dsp file here
</div>

<form id="upload" action="CompilerResponse" method="POST" enctype="multipart/form-data">
<input type="hidden" id="MAX_FILE_SIZE" name="MAX_FILE_SIZE" value="50000000" />
</form>

<script src="file://localhost/usr/local/lib/faust/js/jsscripts.js"></script>
<script src="file://localhost/usr/local/lib/faust/libfaust.js"></script>
<script src="file://localhost/usr/local/lib/faust/webaudio/webaudio-asm-wrapper.js"></script>
<script src="file://localhost/usr/local/lib/faust/webaudio/WebMIDIAPI.js"></script>
        
<script type="text/javascript">

// Faust part

(function() {

    var isWebKitAudio = (typeof (webkitAudioContext) !== "undefined");
    var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();
    var buffer_size = 1024;
    var audio_input = null;
    var midi_input = [];
    var factory = null;
    var DSP = null;
    var dsp_code = null;
    var faustsvg = null;
    var isPoly = false;
    
    // MIDI input handling
    function keyOn(channel, pitch, velocity)
    {
        if (DSP && isPoly) {
            DSP.keyOn(channel, pitch, velocity);
        }
    }

    function keyOff(channel, pitch)
    {
        if (DSP && isPoly) {
            DSP.keyOff(channel, pitch);
        }
    }

    function pitchBend(channel, bend)
    {
        if (DSP && isPoly) {
            DSP.pitchBend(channel, bend);
        }
    }

    function ctrlChange(channel, ctrl, value)
    {
        if (DSP && isPoly) {
            DSP.ctrlChange(channel, ctrl, value);
        }
    }

    function midiMessageReceived(ev) 
    {
        var cmd = ev.data[0] >> 4;
        var channel = ev.data[0] & 0xf;
        var data1 = ev.data[1];
        var data2 = ev.data[2];
      
        if (channel === 9) {
            return;
        } else if (cmd === 8 || ((cmd === 9) && (data2 === 0))) { 
            keyOff(channel, data1);
        } else if (cmd === 9) {
            keyOn(channel, data1, data2);
        } else if (cmd === 11) {
            ctrlChange(channel, data1, data2);
        } else if (cmd === 14) {
            pitchBend(channel, ((data2 * 128.0 + data1)-8192)/8192.0);
        }  
    }

    function onerrorcallback(error) 
    {
         console.log(error);
    }

    function onsuccesscallbackJazz(access) 
    {
        var inputs = access.getInputs();
        for (var i = 0; i <inputs.length; i++) {
            var input = access.getInput(inputs[i]);
            midi_input.push(input);
            input.onmessage = midiMessageReceived;
        }
    }

    function onsuccesscallbackStandard(access) 
    {
        for (var input of access.inputs.values()) {
            midi_input.push(input);
            input.onmidimessage = midiMessageReceived;
            console.log(input.name);
        }
    }
     
    function activateMIDIInput()
    {
        console.log("activateMIDIInput");
        if (typeof (navigator.requestMIDIAccess) !== "undefined") {
            if (navigator.requestMIDIAccess() != undefined) {
                navigator.requestMIDIAccess().then(onsuccesscallbackStandard, onerrorcallback);
            } else{
                navigator.requestMIDIAccess(onsuccesscallbackJazz, onerrorcallback);
            }
         } else {
            alert("MIDI input cannot be activated, either your browser still does't have it, or you need to explicitly activate it.");
        }
    }
 
    // Audio input handling
    function activateAudioInput()
    {
        console.log("activateAudioInput");
        if (!navigator.getUserMedia) {
            navigator.getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        }
        
        if (navigator.getUserMedia) {
            navigator.getUserMedia({audio:true}, getDevice, function(e) {
                    alert('Error getting audio input');
                    console.log(e);
            });
        } else {
            alert('Audio input API not available');
        }
    }

    function getDevice(device) 
    {
        // Create an AudioNode from the stream.
        audio_input = audio_context.createMediaStreamSource(device);
        
        // Connect it to the destination.
        audio_input.connect(DSP.getProcessor());
    }

    function FileDragHover(e) 
    {
        e.stopPropagation();
        e.preventDefault();
        e.target.className = (e.type == "dragover" ? "hover" : "");
    }

    function FileSelectHandler(e) 
    {
        FileDragHover(e);
        var files = e.target.files || e.dataTransfer.files;
        f = files[0];
        UploadFile(f);
    }

    function UploadFile(e) 
    {
        var intAltKey = e.altKey;
        var intShiftKey = e.shiftKey;
     
        FileDragHover(e);
        var files = e.target.files || e.dataTransfer.files;
        var file = files[0];

        if (location.host.indexOf("sitepointstatic") >= 0) return

        var request = new XMLHttpRequest();
        if (request.upload && file.size <= document.getElementById("MAX_FILE_SIZE").value) {

            var reader = new FileReader();
            var ext = file.name.split('.').pop();

            if (ext == "dsp"){
                reader.readAsText(file);  
            }

            reader.onloadend = function(e) {
                dsp_code = reader.result;
                //console.log(dsp_code);
                
                // Remove the current div in ALT key was pressed
                if (intAltKey) {
                    if (DSP) {
                         _f4u$t.hard_delete(faustsvg);
                        DSP.stop();
                        if (isPoly) {
                            faust.deletePolyDSPInstance(DSP);
                        } else {
                            faust.deleteDSPInstance(DSP);
                        }
                        DSP = null;
                    }
                } 
                
                // Create a DSP factory from the dsp code
                factory = faust.createDSPFactory(dsp_code);
                if (!factory) {
                    alert(faust.getErrorMessage());
                    return;
                }
                
                // Then creates one DSP instance
                if (intShiftKey) {
                    isPoly = true;
                    console.log("Poly DSP");
                    DSP = faust.createPolyDSPInstance(factory, audio_context, buffer_size, 16);
                } else {
                    isPoly = false;
                    console.log("Mono DSP");
                    DSP = faust.createDSPInstance(factory, audio_context, buffer_size);
                }
                
                if (DSP.getNumInputs() > 0) {
                    activateAudioInput();
                }
                
                // Setup UI
                _f4u$t.main_loop = function() {}
                
                faustsvg = $('<div />');
                $('body').append(faustsvg);
                var handler = _f4u$t.main(DSP.json(), faustsvg, DSP.setValue);
                DSP.setHandler(handler);
                
                console.log(DSP.getNumInputs());
                console.log(DSP.getNumOutputs());
                
                DSP.start();
            };
        }  else {
            alert("DSP file is too big!");
        }
    }
    
    function Init() 
    {
        activateMIDIInput();
        var filedrag1 = document.getElementById("filedrag");
        filedrag1.addEventListener("dragover", FileDragHover, false);
        filedrag1.addEventListener("dragleave", FileDragHover, false);
        filedrag1.addEventListener("drop", UploadFile, false);
    }

    if (window.File && window.FileList && window.FileReader) {
        Init();
    }
        
})();

</script>

</body>
</html>